#!/usr/bin/env python

################################################################################

import re
import sys
import os
import shutil
import time
import numpy as np
import threading

import datetime as dt

from sqlalchemy import (or_,and_, desc, asc)

from chimera.core.cli import ChimeraCLI, action
from chimera.core.callback import callback
from chimera.util.position import Position
from chimera.util.output import blue, green, red
from chimera.controllers.scheduler.states import State

from t80sched.scheduler import algorithms,queue

#from t80sched.scheduler.model import (Session, Targets, Projects,Program,
#                                      BlockPar,BlockConfig,ObsBlock,Point,Expose,
#                                                 PointVerify, AutoFocus)

from t80sched.scheduler import model as t80db

from chimera.controllers.scheduler import model as cdb
from chimera.controllers.scheduler.status import SchedulerStatus

from chimera.core.site import datetimeFromJD

################################################################################

class ChimeraT80Sched (ChimeraCLI):

    ############################################################################

    def __init__(self):
        ChimeraCLI.__init__(self, "chimera-t80sched",
                            "Scheduler controller", 0.0, port=9010)

        self.obsStart = -1
        #self.addHelpGroup("PJ", "")
        '''
        If no date is specified consider today. Night start/end at Astronomical
        twilight. JDstart/JDend override dates. Even if it is not night,
        observations will be scheduled (can be used for calibrations etc).

        Some scheduling algorithms may require additional parameters, like
        selecting standard stars which the number of targets and observations
        can be different. These are inputed with -f.
        '''

        self.addHelpGroup("RUN", "Start/Stop/Info")

        self.addController(name="site",
                           cls="Site",
                           required=True,
                           help="Observing site",
                           helpGroup="OBSERVATORY")

        self.addController(name="scheduler",
                           cls="Scheduler",
                           required=True,
                           help="Scheduler controller to be used",
                           helpGroup="SCHEDULER")

        self.addController(name="telescope",
                           cls="telescope",
                           required=False,
                           help="Telescope to me used. It is used during queue processing for estimating slew time.",
                           helpGroup="TELESCOPE")

        self.addParameters(dict(name="PID", long="pid", type='string',
                                help="Project ID flag. Use to select targets from DB.",
                                metavar="PID"))
        self.addParameters(dict(name="JDstart", long="jdstart", type=float,
                                help="Julian date of the start of the observations to be scheduled. Override date.",
                                metavar="JDstart"))
        self.addParameters(dict(name="JDend", long="jdend", type=float,
                                help="Julian date at the end of the observations to be scheduled. Override date.",
                                metavar="JDend"))
        self.addParameters(dict(name="dstart", long="dateStart", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss) of the start of the observations to be scheduled.",
                                metavar="dstart"))
        self.addParameters(dict(name="dend", long="dateEnd", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss.s) of the end of the observations to be scheduled.",
                                metavar="dend"))
        self.addParameters(dict(name="filename", long="file", short="f",
                                default="",
                                help="Filename with parameters for scheduling algorith.",
                                metavar="FILENAME"))

    ############################################################################

    @action(long="cleanQueue",
            help="Delete all scheduled blocks from specified project.",
            actionGroup="")
    def cleanQueue(self,opt):

        session = t80db.Session()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(t80db.Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(t80db.Projects).filter(t80db.Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(t80db.Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        self.out('-Deleting all scheduled observing blocks from project %s from the queue.'%opt.PID)

        programs = session.query(t80db.Program).filter(t80db.Program.pid == opt.PID)

        for p in programs:
            self.out(red('--Deleting'))
            self.out( red('---')+'%s'%p )
            for act in p.actions:
                session.delete(act)
                self.out( red('---')+'%s'%act)
            session.delete(p)
            self.out(red('--Done'))

        session.commit()

        sched_blocks = session.query(t80db.ObsBlock).filter(t80db.ObsBlock.pid == opt.PID,
                                                            t80db.ObsBlock.scheduled == 1)

        for sb in sched_blocks:
            sb.scheduled = 0

        session.commit()

        return 0

    ############################################################################

    @action(long="makeQueue",
            help="Select targets from specified project to be observed. ",
            actionGroup="")
    def makeQueue(self,opt):

        session = t80db.Session()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(t80db.Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(t80db.Projects).filter(t80db.Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(t80db.Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        if self.checkQueue(opt.PID):
            self.out(red('+')+'Project already processed... Reprocessing a queue is a nasty job... Clean it and try again...')
            session.commit()
            return 0

        self.out('-Selecting targets from project %s'%opt.PID)

        self.mktimes(opt)

        obsStart = self.obsStart
        obsEnd = self.obsEnd
        lststart = self.lststart-2.
        lstend = self.lstend+2.
        site = self.site

        self.out('-Observation start @ %s | LST = %4.1f h'%(str(obsStart)[:19],lststart))
        self.out('-Observation end   @ %s | LST = %4.1f h'%(str(obsEnd)[:19],lstend))

        obsStart = site.JD(obsStart)
        obsEnd = site.JD(obsEnd)

        ohh = int(np.floor( (obsEnd-obsStart)*24. ))
        omm = int( np.floor( ((obsEnd-obsStart)*24. - ohh) * 60. ))
        self.out('-Observing time: %02i:%02i h'%(ohh,omm))

        # Look for suitable observing blocks for this night...
        FLAG = opt.PID

        ## Select all observing blocks from this project that where not observed
        ## and are not scheduled for observations

        tList = None
        if lststart < lstend:
            tList = session.query(t80db.ObsBlock,t80db.BlockPar,t80db.Targets,t80db.BlockConfig).filter(t80db.ObsBlock.pid == FLAG,
                                                                                                        t80db.BlockConfig.pid == FLAG,
                                                                                                        t80db.BlockPar.pid == FLAG,
                                                                                                        t80db.ObsBlock.scheduled==False,
                                                                                                        t80db.ObsBlock.observed==False,
                                                                                                        t80db.Targets.targetRa > lststart,
                                                                                                        t80db.Targets.targetRa < lstend).join(t80db.BlockPar).join(t80db.Targets).join(t80db.BlockConfig).order_by(t80db.ObsBlock.blockid)
        else:

            tList = session.query(t80db.ObsBlock,t80db.BlockPar,t80db.Targets,t80db.BlockConfig).filter(t80db.ObsBlock.pid == FLAG,
                                                                                t80db.BlockConfig.pid == FLAG,
                                                                                t80db.BlockPar.pid == FLAG,
                                                                                t80db.ObsBlock.scheduled==False,
                                                                                t80db.ObsBlock.observed==False,
                                                                                or_(and_(t80db.Targets.targetRa > lststart,
                                                                                         t80db.Targets.targetRa < 24.),
                                                                                    and_(t80db.Targets.targetRa > 0.,
                                                                                         t80db.Targets.targetRa < lstend))).join(t80db.Targets).join(t80db.BlockConfig).order_by(t80db.ObsBlock.blockid)


        if len(tList[:]) == 0:
            self.out(blue('+')+'No targets available from this project this night...')
            session.commit()
            return -1
        self.out('-Found %i suitable targets...'%(len(tList[:])))

        ## Separate observing blocks by scheduling algoriths

        schedAlgList = np.array([t[1].schedalgorith for t in tList])
        uSAL = np.unique(schedAlgList)

        self.out('-Found %i types of scheduling algorith...'%(len(uSAL)))
        for i,sa_type in enumerate(uSAL):
            self.out('--SA Type[%i] = %i'%(i+1,sa_type))

        for sAL in uSAL:

            nquery = tList.filter(t80db.BlockPar.schedalgorith == sAL)

            qFunction = algorithms.ScheduleFunction(sAL,
                                                    obsStart=obsStart,
                                                    obsEnd=obsEnd,
                                                    s=self,
                                                    query=nquery,
                                                    site=self.site)

            obsTargets = qFunction(self.bestSlotLen(opt.PID))

            # First schedule all
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(t80db.ObsBlock.blockid == bid['blockid'])
                    self.addObservation(oblock,bid['start'])
                #for o in oblock:
                #	o[0].scheduled = True
                #session.commit()

            # Now mark as scheduled
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(t80db.ObsBlock.blockid == bid['blockid'])
                    for o in oblock:
                        o[0].scheduled = True
                    session.commit()


        '''
        blockid = -99
        targetid = -99
        ## Select those that can be observed in this night
        for t in tList:
            #print t

            if blockid != t[0].blockid:
                print t[0]
                print t[1]
                blockid = t[0].blockid

            if targetid != t[2].id:
                print '\t',t[2]
                targetid = t[2].id

            print '\t\t',t[3]

        '''
        session.commit()

    ############################################################################

    @action(long="showQueue",
            help="Show queue result for specified project.",
            actionGroup="")
    def showQueue(self,opt):

        session = Session()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(t80db.Projects).filter(t80db.Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(t80db.Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        programs = session.query(t80db.Program).filter(t80db.Program.pid == opt.PID).order_by(t80db.Program.slewAt)

        odt = np.zeros(programs.count())
        for i,p in enumerate(programs):
            self.out( blue('---')+'[@MJD: %f]%s'%(p.slewAt,p) )
            for ii,act in enumerate(p.actions):
                self.out( blue('---')+'%s'%act)
                if ii > 0:
                    odt[i]+=act.exptime*act.frames
            self.out(blue('--Done'))

        self.mktimes(opt)
        session.commit()
        return 0

        site = self.site

        t0 = site.JD(self.obsStart) #+2400000.5
        tf = site.JD(self.obsEnd)#+2400000.5

        self.out(blue('['+'-'*120+']'))

        NTicks = 120
        dt = NTicks/(tf-t0)
        odt = odt/60./60./24.
        for i,p in enumerate(programs):
            pos = int((np.float(p.slewAt)-t0)*dt)
            nt = int(odt[i]*dt)
            self.out(blue('[')+' '*pos+'-'*nt+' '*(120-pos-nt)+blue(']'))
        self.out(blue('['+'-'*NTicks+']'))
        session.commit()

        return 0


    ############################################################################
    @action(long="processQueue",
            help="Process queue like chimera will do during an observation.",
            actionGroup="")
    def processQueue(self,opt):

        self.mktimes(opt)

        site = self.site
        telescope = self.telescope
        obsStart = site.JD(self.obsStart)-2400000.5
        obsEnd = site.JD(self.obsEnd)-2400000.5
        lststart = self.lststart
        lstend = self.lstend


        otime = obsStart

        appOpen = 0.
        idle = 0.

        qExec = queue.QueueScheduler(site)

        session = t80db.Session()
        telPos = None #current telescope position

        while otime < obsEnd:
            #aP,aplen = self.getAlternateProgram(aprograms,time)
            #if aplen < 0:
            #    break

            program = qExec.next(otime)
            if not program:
                break
            program = session.merge(program)
            aplen = self.calcObsTime(program)

            #while 0 <  aplen/86.4e3 < idleTime:
            msg = ''
            _idle = program.slewAt - otime
            if _idle > 1e-4:
                msg += '[info: Program slew %.3fm in the future. waiting...]'%( (_idle)*24.*60. )
                idle += _idle
            elif _idle < -1e-4:
                msg += '[info: Program slew %.3fm in the past. Slewing now...]'%  ( (_idle)*24.*60. )

            _idle = _idle if _idle > 0 else 0.
            slewtime = 0.
            target = session.query(t80db.Targets).filter(t80db.Targets.id == program.tid).first()
            targetPos = Position.fromRaDec(target.targetRa,target.targetDec)
            if telPos:
                adist = telPos.angsep(targetPos)
                slewtime = np.float(adist.toAS())/60./60./86.4e3 # consider 1 arcmin / second
            slewtime = slewtime if slewtime > _idle else 0 # if slewtime larger than idle time slewtime will be zero
            msg += ' | slewtime = %.5fm'%(slewtime*60.*60.)
            print('@ %.5f (%.5f): Acquiring %45s %s'%(otime,program.slewAt,program,msg))
            dt = (aplen/86.4e3) + slewtime + _idle
            otime+=dt
            appOpen+=aplen
            program.finished = True
            telPos = targetPos
            session.commit()

        aprograms = session.query(t80db.Program).filter(t80db.Program.finished == True)

        for ap in aprograms:
            ap.finished = False
        session.commit()

        self.out('@ %.4f: Idle for %.2fh'%(otime,(obsEnd-otime)*24.))
        idle += (obsEnd-otime)
        self.out('@ %.4f: Night end'%obsEnd)
        self.out('-Total idle time: %.2fh'%(idle*24.))
        self.out('-Total open shutter time: %.2fh'%(appOpen/60./60.))

        '''
        programs = session.query(Program).filter(Program.finished == False).filter(Program.priority == 0).order_by(Program.slewAt)
        aprograms = session.query(Program).filter(Program.finished == False).filter(Program.priority > 0).order_by(Program.slewAt)

        if not programs:
            self.out('Stopping... No programs')

        self.out('-Found %i programs in priority 0 queue' % programs.count())

        self.out('@ %.4f: Night Start'%obsStart)

        for p in programs:
            # Get alternate program
            #aP,aplen = self.getAlternateProgram(time)

            if time <= p.slewAt:
                aP,aplen = self.getAlternateProgram(aprograms,time)
                idleTime = (p.slewAt-time)
                while 0 <  aplen/86.4e3 < idleTime:
                    print('@ %.4f: Acquiring %45s '%(time,aP))
                    time+=(aplen/86.4e3)
                    appOpen+=aplen
                    idleTime = (p.slewAt-time)
                    aP.finished = True
                    session.commit()
                    aP,aplen = self.getAlternateProgram(aprograms,time)
                    if aplen < 0:
                        break

                #self.out('@ %.4f: Idle for %.2fh'%(time,(p.slewAt-time)*24.))
                idle +=  idleTime
                self.out('@ %.4f: Idle for %.2fh | @ %.4f Acquiring %45s '%(time,idleTime*24.,p.slewAt,p)+green('[OK]'))
                etime = 0.
                for ii,act in enumerate(p.actions):
                    if ii > 0:
                        etime+=act.exptime*act.frames
                time = p.slewAt+etime/60./60./24.
                appOpen += etime
            else:
                self.out('Slew@%.4f in the past. Now is %.4f '%(p.slewAt,time)+red('FAIL'))

        while time < obsEnd:
            aP,aplen = self.getAlternateProgram(aprograms,time)
            if aplen < 0:
                break
            idleTime = (obsEnd-time)
            #while 0 <  aplen/86.4e3 < idleTime:
            print('@ %.4f: Acquiring %45s '%(time,aP))
            time+=(aplen/86.4e3)
            appOpen+=aplen
            aP.finished = True
            session.commit()


        self.out('@ %.4f: Idle for %.2fh'%(time,(obsEnd-time)*24.))
        idle += (obsEnd-time)
        self.out('@ %.4f: Night end'%obsEnd)
        self.out('-Total idle time: %.2fh'%(idle*24.))
        self.out('-Total open shutter time: %.2fh'%(appOpen/60./60.))

        aprograms = session.query(Program).filter(Program.priority > 0)

        for ap in aprograms:
            ap.finished = False
        session.commit()
        '''
        return 0

    ############################################################################

    @action(help="Start the scheduler", helpGroup="RUN", actionGroup="RUN")
    def start(self, options):

        e = threading.Event()
        t1 = threading.Thread(  name='waitStart',
                                target=self.start_at_event,
                                args=(e,))
        t1.setDaemon(True)
        t1.start()

        @callback(self.localManager)
        def t80ProgramBeginClbk(program):
            session = cdb.Session()
            program = session.merge(program)
            self.out("=" * 40)
            self.out("%s %s" % (blue("[program]"), program.name))

        @callback(self.localManager)
        def t80ProgramCompleteClbk(program, status, message=None):
            session = cdb.Session()
            program = session.merge(program)
            if status == SchedulerStatus.OK:
                self.out("%s %s %s" %
                         (blue("[program]"), program.name, green(str(status))))
            else:
                self.out("%s %s %s (%s)" % (
                    blue("[program]"), program.name, red(str(status)), red(str(message))))

        @callback(self.localManager)
        def t80ActionBeginClbk(action, message):
            session = cdb.Session()
            action = session.merge(action)
            self.out("%s %s ..." % (blue("[action] "), message), end="")

        @callback(self.localManager)
        def t80ActionCompleteClbk(action, status, message=None):
            session = cdb.Session()
            action = session.merge(action)

            if status == SchedulerStatus.OK:
                self.out("%s" % green(str(status)))
            else:
                self.out("%s (%s)" % (red(str(status)), red(str(message))))

        @callback(self.localManager)
        def t80StateChangedClbk(newState, oldState):
            self.out('%s -> %s'%(oldState,newState))

            if oldState == State.BUSY and newState == State.IDLE:
                self.out("=" * 40)
                self.out("%s: No programs on scheduler database" % blue("[scheduler]"))
                self.out("=" * 40)

                self.addProject()

                e.set()

                #self.scheduler.control()
                #self.exit()

        self.scheduler.programBegin += t80ProgramBeginClbk
        self.scheduler.programComplete += t80ProgramCompleteClbk
        self.scheduler.actionBegin += t80ActionBeginClbk
        self.scheduler.actionComplete += t80ActionCompleteClbk
        self.scheduler.stateChanged += t80StateChangedClbk

        self.addProject()

        self.scheduler.start()

        if self.scheduler.state() == State.OFF:
            self.out("%s no programs to do" % blue("[scheduler]"))
        else:
           self.wait(abort=False)

    ############################################################################

    def addProject(self):

        # looking for something
        site = self.site
        mjd = site.MJD()
        self.out('MJD = %.3f @ %s'%(mjd,site['name']))
        qExec = queue.QueueScheduler(site)

        session = t80db.Session()
        program = qExec.next(mjd)
        if not program:
            self.out("No program in the database...")
            self.exit()
        program = session.merge(program)
        target = session.query(t80db.Targets).filter(t80db.Targets.id == program.tid).first()

        chimeraprogram = cdb.Program( name = target.name,
                                      pi=program.pi,
                                      priority=program.priority,
                                      slewAt=program.slewAt )

        chimerasession = cdb.Session()

        for action in program.actions:
            chimeraAction = chimerasession.merge(self.translateAction(action))
            print action,'->',chimeraAction
            chimeraprogram.actions.append(chimeraAction)

        chimerasession.add(chimeraprogram)
        chimerasession.commit()

    ############################################################################

    def addObservation(self,block,obstime):

        session = t80db.Session()

        self.out('%s'%block[:][0][0])
        self.out('%s'%block[:][0][1])

        targetList = np.array([])

        objname = ""
        programs = []

        for subblock in block:

            if not subblock[0].objid in targetList:

                self.out('\t%s'%subblock[2])

                targetList = np.append(targetList,subblock[0].objid)

                objname = subblock[2].name
                pquery = session.query(t80db.Projects).filter(t80db.Projects.pid == subblock[0].pid)

                program = t80db.Program(tid=subblock[0].objid,name = objname,
                                  pi='',priority=pquery[0].priority,
                                  slewAt=obstime-2400000.5,
                                  pid=subblock[0].pid,
                                  blockid=subblock[0].bparid)#,exposeAt=obstime)


                position = Position.fromRaDec(subblock[2].targetRa,
                                              subblock[2].targetDec,
                                              'J%.0f'%subblock[2].targetEpoch)

                imgtype = subblock[3].imagetype.upper()

                if imgtype == "OBJECT":
                    if position:
                        program.actions.append(t80db.Point(targetRaDec=position))
                    else:
                        program.actions.append(t80db.Point(targetName=objname))
                elif imgtype == "FLAT":
                    site = self._remoteManager.getProxy("/Site/0")
                    flatPosition = Position.fromAltAz(site['flat_alt'], site['flat_az'])
                    program.actions.append(t80db.Point(targetAltAz=flatPosition))
                else:
                    self.out(blue('+')+'No target to point at...')

            self.out( '\t\t%s'%(subblock[3]))
            filter  = subblock[3].filter
            exptime = subblock[3].exptime
            frames  = subblock[3].nexp
            imgtype = subblock[3].imagetype.upper()

            if imgtype in ("OBJECT", "FLAT"):
                shutter = "OPEN"
            else:
                shutter = "CLOSE"

            if imgtype == "BIAS":
                exptime = 0

            if imgtype in ("BIAS", "DARK"):
                filter = None

            program.actions.append(t80db.Expose(shutter=shutter,
                                          filename="%s-%s-$DATE-$TIME" % (subblock[0].pid,objname.replace(" ", "")),
                                          filter=filter,
                                          frames=frames,
                                          exptime=exptime,
                                          imageType=imgtype,
                                          objectName=objname))

            programs.append(program)
        #subblock[0].scheduled = True

        #session.commit()

        session.add_all(programs)
        session.commit()

    ############################################################################

    def checkQueue(self, PID):
        '''Check if projet was already processed...
            '''

        session = t80db.Session()

        progs = session.query(t80db.Program).filter(t80db.Program.pid == PID).first()

        if progs:
            session.commit()
            return True

        session.commit()
        return False

    ############################################################################

    def mktimes(self,opt):
        # Determining start/end times

        site = self.site

        self.obsStart = site.sunset_twilight_end()
        self.obsEnd = site.sunrise_twilight_begin()

        if opt.JDstart:
            self.obsStart = datetimeFromJD(opt.JDstart)
        elif opt.dstart:
            day,hour = opt.dstart.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsStart = dt.datetime(yy,mm,dd,hh,mi,ss)

        if opt.JDend:
            self.obsEnd = datetimeFromJD(opt.JDend)
        elif opt.dend:
            day,hour = opt.dend.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsEnd = dt.datetime(yy,mm,dd,hh,mi,ss)

        self.lststart = site.LST(self.obsStart).toH()
        self.lstend = site.LST(self.obsEnd).toH()

    ############################################################################

    def bestSlotLen(self,pid):

        session = t80db.Session()

        query = session.query(t80db.BlockConfig).filter(t80db.BlockConfig.pid == pid)

        slen = 0

        tottime = np.array([])

        bid = -1
        for blk in query:
            if bid != blk.bid:
                tottime = np.append(tottime,0.)
                bid = blk.bid
            tottime[-1] += blk.nexp*blk.exptime

        session.commit()

        return tottime.min()

    ############################################################################

    def calcObsTime(self,program):
        otime = 0.

        for ii,act in enumerate(program.actions):
            if ii > 0:
                otime+=act.exptime*act.frames
        return otime

    ############################################################################

    def getAlternateProgram(self,programs,nowmjd):

        session = t80db.Session()

        q_plist = session.query(t80db.Projects).filter(t80db.Projects.priority > 0)

        plist = np.unique(np.array([q.priority for q in q_plist]))

        for priority in plist:

            program1 = programs.order_by(desc(t80db.Program.slewAt)).filter(t80db.Program.priority == priority).filter(t80db.Program.slewAt > nowmjd).first()

            program2 = programs.order_by(asc(t80db.Program.slewAt)).filter(t80db.Program.priority == priority).filter(t80db.Program.slewAt < nowmjd).first()

            if not program1 and not program2:
                #self.out('No program in alternate queue %i'%priority)
                continue
            #return None,-1
            elif not program1:
                #self.out('No program1 in alternate queue %i'%priority)
                dT = 0
                for ii,act in enumerate(program2.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program2,dT
            elif not program2:
                #self.out('No program2 in alternate queue %i'%priority)
                dT = 0
                for ii,act in enumerate(program1.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program1,dT

            #self.out('Found 2 suitable programs in alternate queue %i'%priority)

            wtime1 = (program1.slewAt-nowmjd)
            wtime2 = (nowmjd-program2.slewAt)

            if wtime1 < wtime2:
                #self.out('Program1 closer')
                dT = 0
                for ii,act in enumerate(program1.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program1,dT
            else:
                #self.out('Program2 closer')
                dT = 0
                for ii,act in enumerate(program2.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program2,dT

        session.commit()
        return None,-1

    ############################################################################

    def translateAction(self,action):
        '''
        Take an action from t80sched-database and translate it to a
        chimera-database.

        :param action:
        :return: action
        '''

        session = t80db.Session()
        waction = session.merge(action)

        if isinstance(waction, t80db.Point):
            raction = cdb.Point(targetRaDec=waction.targetRaDec,
                                targetAltAz=waction.targetAltAz,
                                targetName=waction.targetName)
        elif isinstance(waction,t80db.Expose):
            raction = cdb.Expose(filter=waction.filter,
                                 frames=waction.frames,
                                 exptime=waction.exptime,
                                 binning=waction.binning,
                                 window=waction.window,
                                 shutter=waction.shutter,
                                 imageType=waction.imageType,
                                 filename=waction.filename,
                                 objectName=waction.objectName)
        elif isinstance(waction, t80db.AutoFocus):
            raction = cdb.AutoFocus(obsstart=waction.obsstart,
                                    obsend=waction.obsend,
                                    step=waction.step,
                                    filter=waction.filter,
                                    exptime=waction.exptime,
                                    binning=waction.binning,
                                    window=waction.window)
        elif isinstance(waction, t80db.PointVerify):
            raction = cdb.PointVerify(here=waction.here,
                                      choose=waction.choose)
        else:
            raction = None

        return raction
    ############################################################################

    def start_at_event(self,e):
        """Wait for the event to be set before doing anything"""

        e.clear()
        while True:
            event_is_set = e.wait()
            # Start scheduler when event is set
            self.scheduler.start()
            self.out('Event set')
            e.clear()

################################################################################
def main():
    cli = ChimeraT80Sched()
    cli.run(sys.argv)
    cli.wait()

################################################################################

if __name__ == '__main__':

    main()

    ################################################################################