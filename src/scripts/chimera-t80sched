#!/usr/bin/env python

################################################################################

import re
import sys
import os
import shutil
import time
import numpy as np
import threading

import datetime as dt

from sqlalchemy import (or_,and_, desc, asc)

from chimera.core.cli import ChimeraCLI, action, ParameterType
from chimera.core.constants import DEFAULT_PROGRAM_DATABASE
from chimera.core.callback import callback
from chimera.util.position import Position
from chimera.util.output import blue, green, red
from chimera.controllers.scheduler.states import State

from t80sched.scheduler import algorithms,queue

#from t80sched.scheduler.model import (Session, Targets, Projects,Program,
#                                      BlockPar,BlockConfig,ObsBlock,Point,Expose,
#                                                 PointVerify, AutoFocus)

from t80sched.scheduler import model as t80db

from chimera.controllers.scheduler import model as cdb
from chimera.controllers.scheduler.status import SchedulerStatus

from chimera.core.site import datetimeFromJD

################################################################################

class ChimeraT80Sched (ChimeraCLI):

    ############################################################################

    def __init__(self):
        ChimeraCLI.__init__(self, "chimera-t80sched",
                            "Scheduler controller", 0.0, port=9010)

        self.obsStart = -1
        #self.addHelpGroup("PJ", "")
        '''
        If no date is specified consider today. Night start/end at Astronomical
        twilight. JDstart/JDend override dates. Even if it is not night,
        observations will be scheduled (can be used for calibrations etc).

        Some scheduling algorithms may require additional parameters, like
        selecting standard stars which the number of targets and observations
        can be different. These are inputed with -f.
        '''

        self.addHelpGroup("RUN", "Start/Stop/Info")

        self.addController(name="site",
                           cls="Site",
                           required=True,
                           help="Observing site",
                           helpGroup="OBSERVATORY")

        self.addController(name="scheduler",
                           cls="Scheduler",
                           required=True,
                           help="Scheduler controller to be used",
                           helpGroup="SCHEDULER")

        self.addController(name="telescope",
                           cls="telescope",
                           required=False,
                           help="Telescope to me used. It is used during queue processing for estimating slew time.",
                           helpGroup="TELESCOPE")

        self.addParameters(dict(name="PID", long="pid", type='string',
                                help="Project ID flag. Use to select targets from DB.",
                                metavar="PID"))
        self.addParameters(dict(name="JDstart", long="jdstart", type=float,
                                help="Julian date of the start of the observations to be scheduled. Override date.",
                                metavar="JDstart"))
        self.addParameters(dict(name="JDend", long="jdend", type=float,
                                help="Julian date at the end of the observations to be scheduled. Override date.",
                                metavar="JDend"))
        self.addParameters(dict(name="dstart", long="dateStart", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss) of the start of the observations to be scheduled.",
                                metavar="dstart"))
        self.addParameters(dict(name="dend", long="dateEnd", type='string',
                                help="Date (yyyy/mm/dd-hh:mm:ss.s) of the end of the observations to be scheduled.",
                                metavar="dend"))
        self.addParameters(dict(name="filename", long="file", short="f",
                                default="",
                                help="Filename with parameters for scheduling algorith.",
                                metavar="FILENAME"))
        self.addParameters(dict(name="forceAtStart", long="forceAtStart",
                                default=True,type=ParameterType.BOOLEAN,
                                help="Force option at start.",
                                metavar="SCHEDULER"))
        self.addParameters(dict(name="cleanAtStart", long="cleanAtStart",
                                default=True,type=ParameterType.BOOLEAN,
                                help="Clean chimera database at start.",
                                metavar="SCHEDULER"))

    @action(long="new",
            help="Generate a new database from a text file (excluding all programs already in database)",
            helpGroup="DB",
            actionGroup="DB")
    def newDatabase(self, options):

        # save a copy
        if os.path.exists(DEFAULT_PROGRAM_DATABASE):
            shutil.copy(DEFAULT_PROGRAM_DATABASE, "%s.%s.bak" %
                        (DEFAULT_PROGRAM_DATABASE, time.strftime("%Y%m%d%H%M%S")))

        # delete all programs
        session = cdb.Session()
        programs = session.query(cdb.Program).all()
        for program in programs:
            session.delete(program)
        session.commit()

        self.generateDatabase(options)

    @action(long="append", help="Append programs to database from a text file",
            helpGroup="DB", actionGroup="DB")
    def appendDatabase(self, options):
        self.generateDatabase(options)

    def generateDatabase(self, options):

        f = None
        try:
            f = open(options.filename, "r")
        except:
            self.exit("Could not find '%s'." % options.filename)

        session = cdb.Session()

        lineRe = re.compile('(?P<coord>(?P<ra>[\d:-]+)\s+(?P<dec>\+?[\d:-]+)\s+(?P<epoch>[\dnowNOWJjBb\.]+)\s+)?(?P<imagetype>[\w]+)'
                            '\s+(?P<objname>\'([^\\n\'\\\\]|\\\\.)*\'|"([^\\n"\\\\]|\\\\.)*"|([^ \\n"\\\\]|\\\\.)*)\s+(?P<exposures>[\w\d\s:\*\(\),]*)'
                            '\s+(?P<AG>[\w\d\s\*\(,\.\)]+)?')
        programs = []

        for i, line in enumerate(f):

            if line.startswith("#"):
                continue
            if len(line) == 1:
                continue

            matchs = lineRe.search(line)

            if matchs is None:
                print "Couldn't process line #%d" % i
                continue

            params = matchs.groupdict()

            position = None
            objname = None

            if params.get("coord", None):
                position = Position.fromRaDec(
                    params['ra'], params['dec'], params['epoch'])

            imagetype = params['imagetype'].upper()
            objname = params['objname'].replace("\"", "")

            autoguider = None

            if params.get("AG",None):
                autoguider = params['AG'].replace('(','').replace(')','').replace('\n','').split(',')
                for i,typecheck in enumerate((float,float,int,str,str,bool,int)):
                    try:
                        autoguider[i] = typecheck(autoguider[i])
                    except:
                        autoguider[i] = None

            multiplier, exps = params['exposures'].split("*")
            try:
                multiplier = int(multiplier)
            except ValueError:
                multiplier = 1

            exps = exps.replace("(", "").replace(")", "").strip().split(",")

            for i in range(multiplier):

                program = cdb.Program(
                    name="%s-%03d" % (objname.replace(" ", ""), i))

                self.out("# program: %s" % program.name)

                if imagetype == "OBJECT":
                    if position:
                        program.actions.append(cdb.Point(targetRaDec=position))
                    else:
                        program.actions.append(cdb.Point(targetName=objname))

                    if autoguider is not None:
                        program.actions.append(cdb.AutoGuide(min_exptime=autoguider[0],
                                                         max_exptime=autoguider[1],
                                                         ntries     =autoguider[2],
                                                         filter     =autoguider[3],
                                                         binning    =autoguider[4],
                                                         windowCCD  =autoguider[5],
                                                         box        =autoguider[6]))

                if imagetype == "FLAT" and i == 0:
                    site = self._remoteManager.getProxy("/Site/0")
                    flatPosition = Position.fromAltAz(
                        site['flat_alt'], site['flat_az'])
                    program.actions.append(cdb.Point(targetAltAz=flatPosition))

                # if i == 0:
                #    program.actions.append(AutoFocus(start=1500, end=3000, step=250, filter="R", exptime=10))
                #    program.actions.append(PointVerify(here=True))

                for exp in exps:
                    if exp.count(":") > 1:
                        filter, exptime, frames = exp.strip().split(":")
                    else:
                        filter, exptime = exp.strip().split(":")
                        frames = 1

                    if imagetype in ("OBJECT", "FLAT"):
                        shutter = "OPEN"
                    else:
                        shutter = "CLOSE"

                    if imagetype == "BIAS":
                        exptime = 0

                    if imagetype in ("BIAS", "DARK"):
                        filter = None

                    self.out("%s %s %s filter=%s exptime=%s frames=%s" % (
                        imagetype, objname, str(position), filter, exptime, frames))

                    program.actions.append(cdb.Expose(shutter=shutter,
                                                  filename="%s-$DATE-$TIME" % objname.replace(
                                                      " ", ""),
                                                  filter=filter,
                                                  frames=frames,
                                                  exptime=exptime,
                                                  imageType=imagetype,
                                                  objectName=objname))

                self.out("")
                programs.append(program)

        session.add_all(programs)
        session.commit()

        self.out("Restart the scheduler to run it with the new database.")

    ############################################################################

    @action(long="cleanObservingLog",
            help="Delete entries on Observing Log database. If no date is specified swipe clean the log database. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def cleanObservingLog(self,opt):

        session = t80db.Session()

        self.mktimes(opt)
        # Query all obs logs entries

        query = session.query(t80db.ObservingLog).filter(t80db.ObservingLog.time > self.obsStart,
                                                         t80db.ObservingLog.time <= self.obsEnd)

        for q in query:
            session.delete(q)
            session.commit()

    ############################################################################

    @action(long="cleanQueue",
            help="Delete all scheduled blocks from specified project.",
            actionGroup="")
    def cleanQueue(self,opt):

        session = t80db.Session()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(t80db.Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(t80db.Projects).filter(t80db.Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(t80db.Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        self.out('-Deleting all scheduled observing blocks from project %s from the queue.'%opt.PID)

        programs = session.query(t80db.Program).filter(t80db.Program.pid == opt.PID)

        for p in programs:
            self.out(red('--Deleting'))
            self.out( red('---')+'%s'%p )
            for act in p.actions:
                session.delete(act)
                self.out( red('---')+'%s'%act)
            session.delete(p)
            self.out(red('--Done'))

        session.commit()

        sched_blocks = session.query(t80db.ObsBlock).filter(t80db.ObsBlock.pid == opt.PID,
                                                            t80db.ObsBlock.scheduled == 1)

        for sb in sched_blocks:
            sb.scheduled = 0

        session.commit()

        return 0

    ############################################################################

    @action(long="summary",
            help="Show summary of current scheduler status.",
            actionGroup="")
    def summary(self,opt):

        session = t80db.Session()

        allpid = [ (p.pid,p.priority) for p in session.query(t80db.Projects)]

        self.out("="*40)
        # Check night start and end
        self.mktimes(opt)
        obsStart = self.obsStart
        obsEnd = self.obsEnd
        lststart = self.lststart
        lstend = self.lstend

        self.out('- Observation start @ %s | LST = %4.1f h'%(str(obsStart)[:19],lststart))
        self.out('- Observation end   @ %s | LST = %4.1f h'%(str(obsEnd)[:19],lstend))

        self.out("="*40)
        # Show available projects in the database
        if len(allpid) > 0:
            prep1,prep2 = ("are","s") if len(allpid) > 1 else ("is","")
            self.out("- There %s %i project%s in the database"%(prep1,len(allpid),prep2))
            for pid in allpid:
                sinfo = "(scheduled)" if self.checkQueue(pid[0]) else ""
                self.out("-- %s: priority %i %s"%(pid[0],pid[1],sinfo))
        else:
            self.out("- There are no projects in the database")


        self.out("="*40)
        # Show information about scheduled projects

    ############################################################################

    @action(long="makeQueue",
            help="Select targets from specified project to be observed. ",
            actionGroup="")
    def makeQueue(self,opt):

        session = t80db.Session()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(t80db.Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(t80db.Projects).filter(t80db.Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(t80db.Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        if self.checkQueue(opt.PID):
            self.out(red('+')+'Project already processed... Reprocessing a queue is a nasty job... Clean it and try again...')
            session.commit()
            return 0

        self.out('-Selecting targets from project %s'%opt.PID)

        self.mktimes(opt)

        obsStart = self.obsStart
        obsEnd = self.obsEnd
        lststart = self.lststart-2.
        lstend = self.lstend+2.
        site = self.site

        self.out('-Observation start @ %s | LST = %4.1f h'%(str(obsStart)[:19],lststart))
        self.out('-Observation end   @ %s | LST = %4.1f h'%(str(obsEnd)[:19],lstend))

        obsStart = site.JD(obsStart)
        obsEnd = site.JD(obsEnd)

        ohh = int(np.floor( (obsEnd-obsStart)*24. ))
        omm = int( np.floor( ((obsEnd-obsStart)*24. - ohh) * 60. ))
        self.out('-Observing time: %02i:%02i h'%(ohh,omm))

        # Look for suitable observing blocks for this night...
        FLAG = opt.PID

        ## Select all observing blocks from this project that where not observed
        ## and are not scheduled for observations

        tList = None
        if lststart < lstend:
            tList = session.query(t80db.ObsBlock,t80db.BlockPar,t80db.Targets,t80db.BlockConfig).filter(t80db.ObsBlock.pid == FLAG,
                                                                                                        t80db.BlockConfig.pid == FLAG,
                                                                                                        t80db.BlockPar.pid == FLAG,
                                                                                                        t80db.ObsBlock.scheduled==False,
                                                                                                        t80db.ObsBlock.observed==False,
                                                                                                        t80db.Targets.targetRa > lststart,
                                                                                                        t80db.Targets.targetRa < lstend).join(t80db.BlockPar).join(t80db.Targets).join(t80db.BlockConfig).order_by(t80db.ObsBlock.blockid)
        else:

            tList = session.query(t80db.ObsBlock,t80db.BlockPar,t80db.Targets,t80db.BlockConfig).filter(t80db.ObsBlock.pid == FLAG,
                                                                                t80db.BlockConfig.pid == FLAG,
                                                                                t80db.BlockPar.pid == FLAG,
                                                                                t80db.ObsBlock.scheduled==False,
                                                                                t80db.ObsBlock.observed==False,
                                                                                or_(and_(t80db.Targets.targetRa > lststart,
                                                                                         t80db.Targets.targetRa < 24.),
                                                                                    and_(t80db.Targets.targetRa > 0.,
                                                                                         t80db.Targets.targetRa < lstend))).join(t80db.Targets).join(t80db.BlockConfig).order_by(t80db.ObsBlock.blockid)


        if len(tList[:]) == 0:
            tList = session.query(t80db.ObsBlock,t80db.BlockPar,t80db.Targets,t80db.BlockConfig).filter(t80db.ObsBlock.pid == FLAG,
                                                                                                        t80db.BlockConfig.pid == FLAG,
                                                                                                        t80db.BlockPar.pid == FLAG,
                                                                                                        t80db.ObsBlock.scheduled==False,
                                                                                                        t80db.ObsBlock.observed==False,
                                                                                                        t80db.Targets.type != "OBJECT").join(t80db.BlockPar).join(t80db.Targets).join(t80db.BlockConfig).order_by(t80db.ObsBlock.blockid)

            if len(tList[:]) == 0:
                self.out(blue('+')+'No targets available from this project this night...')
                session.commit()
                return -1
        self.out('-Found %i suitable targets...'%(len(tList[:])))

        ## Separate observing blocks by scheduling algoriths

        schedAlgList = np.array([t[1].schedalgorith for t in tList])
        uSAL = np.unique(schedAlgList)

        self.out('-Found %i types of scheduling algorith...'%(len(uSAL)))
        for i,sa_type in enumerate(uSAL):
            self.out('--SA Type[%i] = %i'%(i+1,sa_type))

        for sAL in uSAL:

            nquery = tList.filter(t80db.BlockPar.schedalgorith == sAL)
            # Todo: Add autoguider action when requested

            qFunction = algorithms.ScheduleFunction(sAL,
                                                    obsStart=obsStart,
                                                    obsEnd=obsEnd,
                                                    s=self,
                                                    query=nquery,
                                                    site=self.site)

            obsTargets = qFunction(self.bestSlotLen(opt.PID))

            # First schedule all
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(t80db.ObsBlock.blockid == bid['blockid'])
                    self.addObservation(oblock,bid['start'])
                #for o in oblock:
                #	o[0].scheduled = True
                #session.commit()

            # Now mark as scheduled
            for bid in obsTargets:
                if bid['blockid'] > 0:
                    oblock = nquery.filter(t80db.ObsBlock.blockid == bid['blockid'])
                    for o in oblock:
                        o[0].scheduled = True
                    session.commit()


        '''
        blockid = -99
        targetid = -99
        ## Select those that can be observed in this night
        for t in tList:
            #print t

            if blockid != t[0].blockid:
                print t[0]
                print t[1]
                blockid = t[0].blockid

            if targetid != t[2].id:
                print '\t',t[2]
                targetid = t[2].id

            print '\t\t',t[3]

        '''
        session.commit()

    ############################################################################

    @action(long="makeObservingLog",
            help="Process entries on Observing Log database and generate charts and graphs with observing information. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def makeObservingLog(self,opt):

        import plotly.plotly as py
        from plotly.graph_objs import Data,Scatter,Layout,Figure,YAxis,Line

        session = t80db.Session()

        self.mktimes(opt)

        query = session.query(t80db.ObservingLog).filter(t80db.ObservingLog.time > self.obsStart,
                                                         t80db.ObservingLog.time <= self.obsEnd)

        tid = np.array([],dtype=np.int)

        for q in query:
            tid = np.append(tid,q.tid)
            #self.out('%s'%q)

        tid = np.unique(tid)

        # site = self.site()
        trace = []

        color = {7 : 'red',
                 1 : 'blue'}

        for id in tid:
            target = session.query(t80db.Targets).filter(t80db.Targets.id == id)[0]
            time,alt = self.altitude(ra = target.targetRa,
                                     dec = target.targetDec,
                                     start = self.obsStart,
                                     end = self.obsEnd,
                                     tdelta=1./30.)
            trace.append(Scatter(x = time,
                                 y = alt, #np.exp(1.-1./secz)
                                 mode='lines',
                                 line=Line(
                                        color='red',
                                        width=0.5
                                        )
                                 )
                         )

            targetObs = query.filter(t80db.ObservingLog.tid == id)
            start = []
            end = []

            for obs in targetObs:
                if 'Acquisition Start' in obs.action:
                    start.append(obs.time)
                elif 'Acquisition End' in obs.action:
                    end.append(obs.time)
            if len(start) != len(end):
                self.err('Start/end of observations of target does not match')
                continue

            for i in range(len(start)):
                time,alt = self.altitude(ra = target.targetRa,
                                         dec = target.targetDec,
                                         start = start[i],
                                         end = end[i],
                                         tdelta=1./60.)

                trace.append(Scatter(x = time,
                                     y = alt, #np.exp(1.-1./secz)
                                     mode='lines',
                                     line=Line(
                                            color=color[int(targetObs[i].priority)],
                                            width=1.0
                                            ),
                                     fill='tozeroy',
                                     name=target.name
                                     )
                             )


        data = Data(trace)
        layout = Layout(yaxis=YAxis(autorange='reversed'))
        fig = Figure(data=data)#, layout=layout)
        plot_url = py.plot(fig, filename='airmass')
        #plot_url = py.plot(data, filename='airmass')

    ############################################################################

    @action(long="showQueue",
            help="Show queue result for specified project.",
            actionGroup="")
    def showQueue(self,opt):

        session = Session()

        if not opt.PID:
            allpid = [ p.pid for p in session.query(Projects)]
            merr = red('*')+'Specify project id (--pid). Available options are:'
            for pid in allpid:
                merr += '\n'+red('**')+'%s'%pid
            self.err(merr)
            session.commit()
            return -1
        else:
            p = session.query(t80db.Projects).filter(t80db.Projects.pid == opt.PID).count()
            if p == 0:
                allpid = [ p.pid for p in session.query(t80db.Projects)]
                merr = red('*')+'No project named %s on the database. Available options are:'%opt.PID
                for pid in allpid:
                    merr += '\n'+red('**')+'%s'%pid
                self.err(merr)
                session.commit()
                return -1

        programs = session.query(t80db.Program).filter(t80db.Program.pid == opt.PID).order_by(t80db.Program.slewAt)

        odt = np.zeros(programs.count())
        for i,p in enumerate(programs):
            self.out( blue('---')+'[@MJD: %f]%s'%(p.slewAt,p) )
            for ii,act in enumerate(p.actions):
                self.out( blue('---')+'%s'%act)
                if ii > 0:
                    odt[i]+=act.exptime*act.frames
            self.out(blue('--Done'))

        self.mktimes(opt)
        session.commit()
        return 0

        site = self.site

        t0 = site.JD(self.obsStart) #+2400000.5
        tf = site.JD(self.obsEnd)#+2400000.5

        self.out(blue('['+'-'*120+']'))

        NTicks = 120
        dt = NTicks/(tf-t0)
        odt = odt/60./60./24.
        for i,p in enumerate(programs):
            pos = int((np.float(p.slewAt)-t0)*dt)
            nt = int(odt[i]*dt)
            self.out(blue('[')+' '*pos+'-'*nt+' '*(120-pos-nt)+blue(']'))
        self.out(blue('['+'-'*NTicks+']'))
        session.commit()

        return 0


    ############################################################################

    @action(long="showObservingLog",
            help="Show entries on Observing Log database. User can specify start/end dates, only start or end works as well.",
            actionGroup="")
    def showObservingLog(self,opt):

        session = t80db.Session()

        self.mktimes(opt)

        query = session.query(t80db.ObservingLog).filter(t80db.ObservingLog.time > self.obsStart,
                                                         t80db.ObservingLog.time <= self.obsEnd).order_by(t80db.ObservingLog.time)

        for q in query:
            self.out('%s'%q)

    ############################################################################

    @action(long="processQueue",
            help="Process queue like chimera will do during an observation.",
            actionGroup="")
    def processQueue(self,opt):

        self.mktimes(opt)

        site = self.site
        telescope = self.telescope
        obsStart = site.JD(self.obsStart)-2400000.5
        obsEnd = site.JD(self.obsEnd)-2400000.5
        lststart = self.lststart
        lstend = self.lstend


        otime = obsStart

        appOpen = 0.
        idle = 0.

        qExec = queue.QueueScheduler(site)

        session = t80db.Session()
        telPos = None #current telescope position

        while otime < obsEnd:
            #aP,aplen = self.getAlternateProgram(aprograms,time)
            #if aplen < 0:
            #    break
            self.out('Requesting target @ %f'%otime)
            program = qExec.next(otime)
            if not program:
                break
            program = session.merge(program)
            aplen = self.calcObsTime(program)

            #while 0 <  aplen/86.4e3 < idleTime:
            msg = ''
            slewAt = float(program.slewAt)
            _idle = slewAt - otime
            if _idle*24.*60.*60. < aplen:
                slewAt = otime
                _idle = 0.
            # print slewAt,otime
            stime = otime
            if _idle > 1e-4:
                msg += '[info: Program slew %.3fm in the future. waiting...]'%( (_idle)*24.*60. )
                idle += _idle
                stime+=_idle
            elif _idle < -1e-4:
                msg += '[info: Program slew %.3fm in the past. Slewing now...]'%  ( (_idle)*24.*60. )

            _idle = _idle if _idle > 0 else 0.
            slewtime = 0.
            target = session.query(t80db.Targets).filter(t80db.Targets.id == program.tid).first()
            targetPos = Position.fromRaDec(target.targetRa,target.targetDec)
            if telPos:
                adist = telPos.angsep(targetPos)
                slewtime = np.float(adist.toAS())/60./60./86.4e3 # consider 1 arcmin / second
            slewtime = slewtime if slewtime > _idle else 0 # if slewtime larger than idle time slewtime will be zero
            msg += ' | slewtime = %.5fm'%(slewtime*60.*60.)
            self.out('@ %.5f (%.5f): Acquiring %45s %s'%(otime,slewAt,program,msg))
            log = t80db.ObservingLog(time=datetimeFromJD(stime+2400000.5,),
                                     tid=program.tid,
                                     name=program.name,
                                     priority=program.priority,
                                     action='Simulation: Acquisition Start')
            session.add(log)
            session.commit()

            log = t80db.ObservingLog(time=datetimeFromJD(stime+(aplen/86.4e3)+2400000.5,),
                         tid=program.tid,
                         name=program.name,
                         priority=program.priority,
                         action='Simulation: Acquisition End')
            session.add(log)

            dt = (aplen/86.4e3) + slewtime + _idle
            otime+=dt

            appOpen+=aplen
            program.finished = True
            telPos = targetPos
            session.commit()

        aprograms = session.query(t80db.Program).filter(t80db.Program.finished == True)

        for ap in aprograms:
            ap.finished = False
        session.commit()

        self.out('@ %.4f: Idle for %.2fh'%(otime,(obsEnd-otime)*24.))
        idle += (obsEnd-otime)
        self.out('@ %.4f: Night end'%obsEnd)
        self.out('-Total idle time: %.2fh'%(idle*24.))
        self.out('-Total open shutter time: %.2fh'%(appOpen/60./60.))

        '''
        programs = session.query(Program).filter(Program.finished == False).filter(Program.priority == 0).order_by(Program.slewAt)
        aprograms = session.query(Program).filter(Program.finished == False).filter(Program.priority > 0).order_by(Program.slewAt)

        if not programs:
            self.out('Stopping... No programs')

        self.out('-Found %i programs in priority 0 queue' % programs.count())

        self.out('@ %.4f: Night Start'%obsStart)

        for p in programs:
            # Get alternate program
            #aP,aplen = self.getAlternateProgram(time)

            if time <= p.slewAt:
                aP,aplen = self.getAlternateProgram(aprograms,time)
                idleTime = (p.slewAt-time)
                while 0 <  aplen/86.4e3 < idleTime:
                    print('@ %.4f: Acquiring %45s '%(time,aP))
                    time+=(aplen/86.4e3)
                    appOpen+=aplen
                    idleTime = (p.slewAt-time)
                    aP.finished = True
                    session.commit()
                    aP,aplen = self.getAlternateProgram(aprograms,time)
                    if aplen < 0:
                        break

                #self.out('@ %.4f: Idle for %.2fh'%(time,(p.slewAt-time)*24.))
                idle +=  idleTime
                self.out('@ %.4f: Idle for %.2fh | @ %.4f Acquiring %45s '%(time,idleTime*24.,p.slewAt,p)+green('[OK]'))
                etime = 0.
                for ii,act in enumerate(p.actions):
                    if ii > 0:
                        etime+=act.exptime*act.frames
                time = p.slewAt+etime/60./60./24.
                appOpen += etime
            else:
                self.out('Slew@%.4f in the past. Now is %.4f '%(p.slewAt,time)+red('FAIL'))

        while time < obsEnd:
            aP,aplen = self.getAlternateProgram(aprograms,time)
            if aplen < 0:
                break
            idleTime = (obsEnd-time)
            #while 0 <  aplen/86.4e3 < idleTime:
            print('@ %.4f: Acquiring %45s '%(time,aP))
            time+=(aplen/86.4e3)
            appOpen+=aplen
            aP.finished = True
            session.commit()


        self.out('@ %.4f: Idle for %.2fh'%(time,(obsEnd-time)*24.))
        idle += (obsEnd-time)
        self.out('@ %.4f: Night end'%obsEnd)
        self.out('-Total idle time: %.2fh'%(idle*24.))
        self.out('-Total open shutter time: %.2fh'%(appOpen/60./60.))

        aprograms = session.query(Program).filter(Program.priority > 0)

        for ap in aprograms:
            ap.finished = False
        session.commit()
        '''
        return 0

    ############################################################################

    @action(help="Start the scheduler", helpGroup="RUN", actionGroup="RUN")
    def start(self, options):


        self.mktimes(options)

        self.out('%s: Observations start @ %s'%(blue("[T80S-scheduler]"),self.mjdStart))
        self.out('%s: Observations end @ %s'%(blue("[T80S-scheduler]"),self.mjdEnd))

        e = threading.Event()
        t1 = threading.Thread(  name='waitStart',
                                target=self.start_at_event,
                                args=(e,))
        t1.setDaemon(True)
        t1.start()

        @callback(self.localManager)
        def t80ProgramBeginClbk(program):
            session = cdb.Session()
            program = session.merge(program)
            self.out("=" * 40)
            self.out("%s %s" % (blue("[program]"), program.name))

        @callback(self.localManager)
        def t80ProgramCompleteClbk(program, status, message=None):
            session = cdb.Session()
            program = session.merge(program)
            if status == SchedulerStatus.OK:
                self.out("%s %s %s" %
                         (blue("[program]"), program.name, green(str(status))))
            else:
                self.out("%s %s %s (%s)" % (
                    blue("[program]"), program.name, red(str(status)), red(str(message))))

            sessionT80 = t80db.Session()
            t80program = sessionT80.query(t80db.Program).filter(t80db.Program.id == program.tid).first()
            t80program.finished = True
            sessionT80.commit()

        @callback(self.localManager)
        def t80ActionBeginClbk(action, message):
            session = cdb.Session()
            action = session.merge(action)
            self.out("%s %s ..." % (blue("[action] "), message), end="")

        @callback(self.localManager)
        def t80ActionCompleteClbk(action, status, message=None):
            session = cdb.Session()
            action = session.merge(action)

            if status == SchedulerStatus.OK:
                self.out("%s" % green(str(status)))
            else:
                self.out("%s (%s)" % (red(str(status)), red(str(message))))

        @callback(self.localManager)
        def t80StateChangedClbk(newState, oldState):
            self.out('%s: %s -> %s'%(blue("[state]"),oldState,newState))

            if oldState == State.BUSY and newState == State.IDLE:
                # When state changes from BUSY to IDLE, feed new program and
                # issue a signal to the function that will tell the scheduler
                # to start again...
                self.out("=" * 40)
                self.out("%s: No programs on chimera-scheduler database" % blue("[T80S-scheduler]"))
                self.out("=" * 40)

                #self.addProject()
                #if (self.mjdStart < self.site.MJD())
                e.set()

                #self.scheduler.control()
                #self.exit()

        self.scheduler.programBegin += t80ProgramBeginClbk
        self.scheduler.programComplete += t80ProgramCompleteClbk
        self.scheduler.actionBegin += t80ActionBeginClbk
        self.scheduler.actionComplete += t80ActionCompleteClbk
        self.scheduler.stateChanged += t80StateChangedClbk

        if self.scheduler.state() == State.OFF:

            self.addProject(force=options.forceAtStart,
                            clean=options.cleanAtStart)

            self.scheduler.start()

            if self.scheduler.state() == State.OFF:
                self.out("%s no programs to do" % red("[T80S-scheduler]"))
                self.exit()
            else:
                self.wait(abort=False)

        else:
            # If chimera-scheduler is working, than just wait for it to
            # callback for programs...
            self.out("%s: Scheduler state is '%s'. Waiting call for programs..."%(blue("[T80S-scheduler]"),
                                                                                self.scheduler.state()))
            self.wait(abort=False)

    ############################################################################

    @action(help="Monitor scheduler actions", helpGroup="RUN")
    def monitor(self, options):


        ########################################################################

        @callback(self.localManager)
        def programBeginClbk(program):
            chimera_session = cdb.Session()
            program = chimera_session.merge(program)
            t80s_session = t80db.Session()
            log = t80db.ObservingLog(time=dt.datetime.now(),
                                     tid=program.tid,
                                     name=program.name,
                                     action='Program begin.')
            self.out("=" * 40)
            self.out("%s %s" % (blue("[program]"), program.name))

        ########################################################################


        @callback(self.localManager)
        def programCompleteClbk(program, status, message=None):
            session = cdb.Session()
            program = session.merge(program)
            if status == SchedulerStatus.OK:
                self.out("%s %s %s" %
                         (blue("[program]"), program.name, green(str(status))))
            else:
                self.out("%s %s %s (%s)" % (
                    blue("[program]"), program.name, red(str(status)), red(str(message))))

        ########################################################################

        @callback(self.localManager)
        def actionBeginClbk(action, message):
            session = cdb.Session()
            action = session.merge(action)
            self.out("%s %s ..." % (blue("[action] "), message), end="")

        ########################################################################

        @callback(self.localManager)
        def actionCompleteClbk(action, status, message=None):
            session = cdb.Session()
            action = session.merge(action)

            if status == SchedulerStatus.OK:
                self.out("%s" % green(str(status)))
            else:
                self.out("%s (%s)" % (red(str(status)), red(str(message))))

        ########################################################################

        @callback(self.localManager)
        def stateChangedClbk(newState, oldState):
            if newState == State.OFF:
                self.out("=" * 40)
                self.out("%s finished all programs" % blue("[scheduler]"))
                self.out("=" * 40)
                self.exit()

        ########################################################################

        self.scheduler.programBegin += programBeginClbk
        self.scheduler.programComplete += programCompleteClbk
        self.scheduler.actionBegin += actionBeginClbk
        self.scheduler.actionComplete += actionCompleteClbk
        self.scheduler.stateChanged += stateChangedClbk

        if self.scheduler.state() == State.OFF:
            self.out("%s no programs to do" % blue("[scheduler]"))
        else:
            self.wait(abort=False)

    ############################################################################

    def addProject(self,force=False,clean=False):
        '''
        Select program from T80-scheduler database and inject them in chimera
        scheduler database. Only one program will be injected at a time, but
        with all its actions. The force and clean parameters controls the
        behaviour in case there is something already in chimera database.

        Remember that chimera scheduler is dumb. It will take what ever is
        in the database and observe in order of appearance! So even if there is
        a program with earlier slewAt it is not guaranteed that it will be observed
        first.

        The combination of clean and force must be used with care. If clean is
        True and force is False, it will check the status of the scheduler
        first. If the scheduler is executing a project (state = BUSY) nothing
        will be done. On the other hand, if both clean and force are True,
        it will stop the scheduler (if it is executing), clean the queue, and
        so on.

        :param force: True  - Inject new program nonetheless.
                      False - (default) Inject program only if chimera db is
                               empty.

        :param clean: True  - If there is anything in chimera db clean it
                              first.
                      False - (default) Does not change chimera db.

        :return:
        '''

        chimerasession = cdb.Session()

        chimeraprogram = chimerasession.query(cdb.Program).filter(cdb.Program.finished==False)

        busy = self.scheduler.state() == State.BUSY

        if chimeraprogram.count() > 0 and ( ( clean and not busy ) or ( clean and force ) ):
            # There are programs on chimera queue and it will be cleaned
            if busy:
                # if chimera-scheduler is running stop it before cleaning database
                self.out('%s Stopping scheduler..'%(blue('[T80S-scheduler]')))
                self.scheduler.stop()
            # Now clean chimera db
            self.out('%s Cleaning chimera database'%(red('[T80S-scheduler]')))
            for p in chimeraprogram:
                p = chimerasession.merge(p)
                self.out(red('-Deleting'))
                self.out( red('|')+'%s'%p )
                for act in p.actions:
                    act = chimerasession.merge(act)
                    chimerasession.delete(act)
                    self.out( red('|')+'%s'%act)
                chimerasession.delete(p)
                self.out(red('-Done'))

            chimerasession.commit()
        elif chimeraprogram.count() > 0 and not force:
            self.out('%s Scheduler has programs, running on no-force mode... skipping...'%(blue('[T80S-scheduler]')))
            return


        self.out('%s Looking for something to do...'%(blue('T80S-scheduler')))
        site = self.site
        mjd = site.MJD()
        self.out('%s: MJD = %.3f @ %s'%(blue("[T80S-scheduler]"), mjd,site['name']))
        qExec = queue.QueueScheduler(site)

        session = t80db.Session()
        program = qExec.next(mjd)
        if not program:
            self.out("%s: No program in the database..."%(red("[T80S-scheduler]")))
            self.exit()
        program = session.merge(program)
        target = session.query(t80db.Targets).filter(t80db.Targets.id == program.tid).first()

        chimeraprogram = cdb.Program( name = target.name,
                                      tid = program.id, # I will use tid to store the id of the program so I can log it latter!
                                      pi=program.pi,
                                      priority=program.priority,
                                      slewAt=program.slewAt )

        for action in program.actions:
            chimeraAction = chimerasession.merge(self.translateAction(action))
            self.out('%s: %s -> %s '%(blue("[T80S-scheduler]"), action,chimeraAction) )
            chimeraprogram.actions.append(chimeraAction)

        chimerasession.add(chimeraprogram)
        chimerasession.commit()

    ############################################################################

    def addObservation(self,block,obstime):

        session = t80db.Session()

        self.out('%s'%block[:][0][0])
        self.out('%s'%block[:][0][1])

        targetList = np.array([])

        objname = ""
        programs = []

        for subblock in block:

            if not subblock[0].objid in targetList:

                self.out('\t%s'%subblock[2])

                targetList = np.append(targetList,subblock[0].objid)

                objname = subblock[2].name
                pquery = session.query(t80db.Projects).filter(t80db.Projects.pid == subblock[0].pid)

                program = t80db.Program(tid=subblock[0].objid,name = objname,
                                  pi='',priority=pquery[0].priority,
                                  slewAt=obstime-2400000.5,
                                  pid=subblock[0].pid,
                                  blockid=subblock[0].bparid)#,exposeAt=obstime)


                position = Position.fromRaDec(subblock[2].targetRa,
                                              subblock[2].targetDec,
                                              'J%.0f'%subblock[2].targetEpoch)

                imgtype = subblock[3].imagetype.upper()

                if imgtype == "OBJECT":
                    if position:
                        program.actions.append(t80db.Point(targetRaDec=position))
                    else:
                        program.actions.append(t80db.Point(targetName=objname))
                elif imgtype == "FLAT":
                    site = self._remoteManager.getProxy("/Site/0")
                    flatPosition = Position.fromAltAz(site['flat_alt'], site['flat_az'])
                    program.actions.append(t80db.Point(targetAltAz=flatPosition))
                else:
                    self.out(blue('+')+'ImageType: %s: No target to point at...'%imgtype)

            self.out( '\t\t%s'%(subblock[3]))
            filter  = subblock[3].filter
            exptime = subblock[3].exptime
            frames  = subblock[3].nexp
            imgtype = subblock[3].imagetype.upper()

            if imgtype in ("OBJECT", "FLAT"):
                shutter = "OPEN"
            else:
                shutter = "CLOSE"

            if imgtype == "BIAS":
                exptime = 0

            if imgtype in ("BIAS", "DARK"):
                filter = None

            program.actions.append(t80db.Expose(shutter=shutter,
                                          filename="%s-%s-$DATE-$TIME" % (subblock[0].pid,objname.replace(" ", "")),
                                          filter=filter,
                                          frames=frames,
                                          exptime=exptime,
                                          imageType=imgtype,
                                          objectName=objname))

            programs.append(program)
        #subblock[0].scheduled = True

        #session.commit()

        session.add_all(programs)
        session.commit()

    ############################################################################

    def checkQueue(self, PID):
        '''Check if projet was already processed...
            '''

        session = t80db.Session()

        progs = session.query(t80db.Program).filter(t80db.Program.pid == PID).first()

        if progs:
            session.commit()
            return True

        session.commit()
        return False

    ############################################################################

    def mktimes(self,opt):
        # Determining start/end times

        site = self.site

        self.obsStart = site.sunset_twilight_end()
        self.obsEnd = site.sunrise_twilight_begin(self.obsStart)

        if opt.JDstart is not None:
            self.obsStart = datetimeFromJD(opt.JDstart)
        elif opt.dstart is not None:
            day,hour = opt.dstart.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsStart = dt.datetime(yy,mm,dd,hh,mi,ss)

        if opt.JDend is not None:
            self.obsEnd = datetimeFromJD(opt.JDend)
        elif opt.dend is not None:
            day,hour = opt.dend.split('-')
            yy,mm,dd = [int(val) for val in day.split('/')]
            hh,mi,ss = [int(val) for val in hour.split(':') ]
            self.obsEnd = dt.datetime(yy,mm,dd,hh,mi,ss)

        self.lststart = site.LST(self.obsStart).toH()
        self.lstend = site.LST(self.obsEnd).toH()
        self.mjdStart = site.MJD(self.obsStart)
        self.mjdEnd =  site.MJD(self.obsEnd)

    ############################################################################

    def bestSlotLen(self,pid):

        session = t80db.Session()

        query = session.query(t80db.BlockConfig).filter(t80db.BlockConfig.pid == pid)

        slen = 0

        tottime = np.array([])

        bid = -1
        for blk in query:
            if bid != blk.bid:
                tottime = np.append(tottime,0.)
                bid = blk.bid
            tottime[-1] += blk.nexp*blk.exptime

        session.commit()

        return tottime.min()/2.

    ############################################################################

    def calcObsTime(self,program):
        otime = 0.

        for ii,act in enumerate(program.actions):
            if ii > 0:
                otime+=act.exptime*act.frames
        return otime

    ############################################################################

    def getAlternateProgram(self,programs,nowmjd):

        session = t80db.Session()

        q_plist = session.query(t80db.Projects).filter(t80db.Projects.priority > 0)

        plist = np.unique(np.array([q.priority for q in q_plist]))

        for priority in plist:

            program1 = programs.order_by(desc(t80db.Program.slewAt)).filter(t80db.Program.priority == priority).filter(t80db.Program.slewAt > nowmjd).first()

            program2 = programs.order_by(asc(t80db.Program.slewAt)).filter(t80db.Program.priority == priority).filter(t80db.Program.slewAt < nowmjd).first()

            if not program1 and not program2:
                #self.out('No program in alternate queue %i'%priority)
                continue
            #return None,-1
            elif not program1:
                #self.out('No program1 in alternate queue %i'%priority)
                dT = 0
                for ii,act in enumerate(program2.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program2,dT
            elif not program2:
                #self.out('No program2 in alternate queue %i'%priority)
                dT = 0
                for ii,act in enumerate(program1.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program1,dT

            #self.out('Found 2 suitable programs in alternate queue %i'%priority)

            wtime1 = (program1.slewAt-nowmjd)
            wtime2 = (nowmjd-program2.slewAt)

            if wtime1 < wtime2:
                #self.out('Program1 closer')
                dT = 0
                for ii,act in enumerate(program1.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program1,dT
            else:
                #self.out('Program2 closer')
                dT = 0
                for ii,act in enumerate(program2.actions):
                    if ii > 0:
                        dT+=act.exptime*act.frames
                session.commit()
                return program2,dT

        session.commit()
        return None,-1

    ############################################################################

    def translateAction(self,action):
        '''
        Take an action from t80sched-database and translate it to a
        chimera-database.

        :param action:
        :return: action
        '''

        session = t80db.Session()
        waction = session.merge(action)

        if isinstance(waction, t80db.Point):
            raction = cdb.Point(targetRaDec=waction.targetRaDec,
                                targetAltAz=waction.targetAltAz,
                                targetName=waction.targetName)
        elif isinstance(waction,t80db.Expose):
            raction = cdb.Expose(filter=waction.filter,
                                 frames=waction.frames,
                                 exptime=waction.exptime,
                                 binning=waction.binning,
                                 window=waction.window,
                                 shutter=waction.shutter,
                                 imageType=waction.imageType,
                                 filename=waction.filename,
                                 objectName=waction.objectName)
        elif isinstance(waction, t80db.AutoFocus):
            raction = cdb.AutoFocus(obsstart=waction.obsstart,
                                    obsend=waction.obsend,
                                    step=waction.step,
                                    filter=waction.filter,
                                    exptime=waction.exptime,
                                    binning=waction.binning,
                                    window=waction.window)
        elif isinstance(waction, t80db.PointVerify):
            raction = cdb.PointVerify(here=waction.here,
                                      choose=waction.choose)
        else:
            raction = None

        return raction
    ############################################################################

    def start_at_event(self,e):
        """Wait for the event to be set before doing anything"""

        e.clear()
        while True:
            event_is_set = e.wait()
            # Start scheduler when event is set
            if self.mjdStart < self.site.MJD() <self.mjdEnd:
                self.out('%s: Feeding and starting observation'%(blue("[T80S-scheduler]")))
                self.addProject()
                self.scheduler.start()
            else:
                self.out('%s: Now is outside night time...'%(blue("[T80S-scheduler]")))
                self.out('%s: Observations start @ %s'%(blue("[T80S-scheduler]"),self.mjdStart))
                self.out('%s: Observations end @ %s'%(blue("[T80S-scheduler]"),self.mjdEnd))
                self.out('%s: Now is %s'%(blue("[T80S-scheduler]"),self.site.MJD()))

            e.clear()

    ############################################################################

    def stop_at_event(self,e):
        """Wait for the event to be set before doing anything"""

        e.clear()
        while True:
            event_is_set = e.wait()
            # Stop scheduler when event is set
            self.scheduler.stop()
            self.out('Event stop')
            e.clear()

    ############################################################################

    def altitude(self,ra,dec,start,end,tdelta=0.5,minA=10.):

        site = self.site

        coords = Position.fromRaDec(ra,
                                 dec)

        timevec = np.array([])
        amvec = np.array([])

        time = start
        while time < end:
        #for time in range(start,end,dt.timedelta(hours=tdelta)):
            #print type(time)
            lst = site.LST_inRads(time)
            alt = float(site.raDecToAltAz(coords,lst).alt)
            # airmass = 1./np.cos(np.pi/2.-alt*np.pi/180.)
            if minA < alt <= 90.:
                timevec = np.append(timevec,time)
                amvec = np.append(amvec,alt)
            time += dt.timedelta(hours=tdelta)

        return timevec,amvec


    ############################################################################

################################################################################
def main():
    cli = ChimeraT80Sched()
    cli.run(sys.argv)
    cli.wait()

################################################################################

if __name__ == '__main__':

    main()

################################################################################